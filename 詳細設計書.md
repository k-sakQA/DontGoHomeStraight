# iPhoneアプリ詳細設計書
**アプリ名：まっすぐ帰りたくない**

---

## 1. システム概要

### 1.1 システム構成図

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   iOS Client    │◄──►│  OpenAI API     │    │ Google Maps API │
│                 │    │                 │    │                 │
│ - SwiftUI View  │    │ - ChatGPT API   │    │ - Places API    │
│ - Core Location │    │ - 経由地提案    │    │ - Directions    │
│ - MapKit        │    │                 │    │ - Geocoding     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 1.2 技術スタック

- **フロントエンド**: SwiftUI, UIKit (iOS 15.0+)
- **地図・位置情報**: Core Location, MapKit, Google Maps SDK
- **ネットワーク**: URLSession, Combine
- **AI連携**: OpenAI API (GPT-4)
- **外部API**: Google Places API, Google Directions API
- **テスティング**: XCTest (TDD)
- **設定管理**: .env, Bundle Configuration

---

## 2. アーキテクチャ設計

### 2.1 レイヤー構成（Clean Architecture）

```
┌─────────────────────────────────┐
│         Presentation Layer       │
│  ┌─────────┐  ┌─────────────┐   │
│  │  View   │  │ ViewModel   │   │
│  └─────────┘  └─────────────┘   │
└─────────────────────────────────┘
┌─────────────────────────────────┐
│           Domain Layer           │
│  ┌─────────┐  ┌─────────────┐   │
│  │ Entity  │  │  UseCase    │   │
│  └─────────┘  └─────────────┘   │
└─────────────────────────────────┘
┌─────────────────────────────────┐
│            Data Layer            │
│  ┌─────────┐  ┌─────────────┐   │
│  │Repository│ │DataSource   │   │
│  └─────────┘  └─────────────┘   │
└─────────────────────────────────┘
```

### 2.2 ディレクトリ構造

```
DontGoHomeStraight/
├── App/
│   ├── DontGoHomeStraightApp.swift
│   └── Config/
│       ├── Environment.swift
│       └── APIKeys.swift
├── Presentation/
│   ├── Views/
│   │   ├── HomeView.swift
│   │   ├── DestinationSettingView.swift
│   │   ├── TransportModeView.swift
│   │   ├── MoodSelectionView.swift
│   │   ├── GenreSelectionView.swift
│   │   ├── NavigationView.swift
│   │   └── ArrivalView.swift
│   ├── ViewModels/
│   │   ├── HomeViewModel.swift
│   │   ├── DestinationViewModel.swift
│   │   ├── MoodSelectionViewModel.swift
│   │   ├── GenreSelectionViewModel.swift
│   │   └── NavigationViewModel.swift
│   └── Components/
│       ├── MoodButtonGroup.swift
│       ├── TransportModeSelector.swift
│       └── CustomMapView.swift
├── Domain/
│   ├── Entities/
│   │   ├── Destination.swift
│   │   ├── TransportMode.swift
│   │   ├── Mood.swift
│   │   ├── Place.swift
│   │   ├── Genre.swift
│   │   └── NavigationRoute.swift
│   ├── UseCases/
│   │   ├── DestinationUseCase.swift
│   │   ├── MoodSelectionUseCase.swift
│   │   ├── PlaceRecommendationUseCase.swift
│   │   ├── GenreSelectionUseCase.swift
│   │   └── NavigationUseCase.swift
│   └── Repositories/
│       ├── LocationRepository.swift
│       ├── PlaceRepository.swift
│       ├── AIRecommendationRepository.swift
│       └── CacheRepository.swift
├── Data/
│   ├── Repositories/
│   │   ├── LocationRepositoryImpl.swift
│   │   ├── PlaceRepositoryImpl.swift
│   │   ├── AIRecommendationRepositoryImpl.swift
│   │   └── CacheRepositoryImpl.swift
│   ├── DataSources/
│   │   ├── Local/
│   │   │   ├── UserDefaultsDataSource.swift
│   │   │   └── CoreDataStack.swift
│   │   └── Remote/
│   │       ├── OpenAIAPIClient.swift
│   │       ├── GooglePlacesAPIClient.swift
│   │       └── GoogleMapsAPIClient.swift
│   └── Models/
│       ├── OpenAIRequest.swift
│       ├── OpenAIResponse.swift
│       ├── GooglePlacesResponse.swift
│       └── CachedPlace.swift
├── Utils/
│   ├── Extensions/
│   │   ├── CLLocation+Extension.swift
│   │   └── String+Extension.swift
│   ├── Managers/
│   │   ├── LocationManager.swift
│   │   └── NetworkManager.swift
│   └── Constants/
│       ├── AppConstants.swift
│       └── APIConstants.swift
└── Tests/
    ├── DomainTests/
    ├── DataTests/
    ├── PresentationTests/
    └── TestHelpers/
```

---

## 3. データモデル設計

### 3.1 エンティティ定義

#### 3.1.1 Destination（目的地）

```swift
struct Destination {
    let id: UUID
    let name: String
    let coordinate: CLLocationCoordinate2D
    let address: String
    let createdAt: Date
}
```

#### 3.1.2 TransportMode（移動手段）

```swift
enum TransportMode: String, CaseIterable {
    case walking = "walking"
    case driving = "driving"
    case transit = "transit"
    case cycling = "cycling"
    
    var displayName: String {
        switch self {
        case .walking: return "徒歩"
        case .driving: return "車"
        case .transit: return "公共交通機関"
        case .cycling: return "自転車"
        }
    }
    
    var icon: String {
        switch self {
        case .walking: return "figure.walk"
        case .driving: return "car"
        case .transit: return "tram"
        case .cycling: return "bicycle"
        }
    }
}
```

#### 3.1.3 Mood（気分）

```swift
struct Mood {
    let activityType: ActivityType
    let vibeType: VibeType
}

enum ActivityType: String, CaseIterable {
    case indoor = "indoor"
    case outdoor = "outdoor"
    
    var displayName: String {
        switch self {
        case .indoor: return "インドア"
        case .outdoor: return "アウトドア"
        }
    }
}

enum VibeType: String, CaseIterable {
    case jazzy = "jazzy"
    case discovery = "discovery"
    case exciting = "exciting"
    
    var displayName: String {
        switch self {
        case .jazzy: return "Jazzy"
        case .discovery: return "発見！"
        case .exciting: return "ワクワク"
        }
    }
}
```

#### 3.1.4 Place（場所）

```swift
struct Place {
    let id: String
    let name: String
    let coordinate: CLLocationCoordinate2D
    let address: String
    let genre: Genre
    let rating: Double?
    let priceLevel: Int?
    let photoReference: String?
    let isOpen: Bool?
    let placeId: String
}
```

#### 3.1.5 Genre（ジャンル）

```swift
struct Genre {
    let id: String
    let name: String
    let category: GenreCategory
    let googleMapType: String
}

enum GenreCategory: String {
    case restaurant = "restaurant"
    case other = "other"
    
    // 30% : 70% の比率
    static func getRandomCategory() -> GenreCategory {
        return Int.random(in: 1...10) <= 3 ? .restaurant : .other
    }
}
```

#### 3.1.6 NavigationRoute（ナビゲーション経路）

```swift
struct NavigationRoute {
    let id: UUID
    let origin: CLLocationCoordinate2D
    let destination: CLLocationCoordinate2D
    let waypoint: Place
    let transportMode: TransportMode
    let totalDistance: CLLocationDistance
    let estimatedDuration: TimeInterval
    let polyline: String
    let createdAt: Date
}
```

### 3.2 API通信モデル

#### 3.2.1 OpenAI API Request

```swift
struct OpenAIRecommendationRequest {
    let currentLocation: CLLocationCoordinate2D
    let destination: CLLocationCoordinate2D
    let currentTime: Date
    let mood: Mood
    let transportMode: TransportMode
    let excludedPlaceIds: [String]
    
    func toPrompt() -> String {
        return """
        現在地: \(currentLocation.latitude), \(currentLocation.longitude)
        目的地: \(destination.latitude), \(destination.longitude)
        現在時刻: \(DateFormatter.apiFormatter.string(from: currentTime))
        気分: \(mood.activityType.displayName) + \(mood.vibeType.displayName)
        移動手段: \(transportMode.displayName)
        除外スポット: \(excludedPlaceIds.joined(separator: ", "))
        
        上記の条件で、経由地として最適な3つのスポットを提案してください。
        飲食店を30%、それ以外を70%の割合で含めてください。
        各スポットについて、GooglePlaces APIで検索可能な具体的な店名または施設名を回答してください。
        """
    }
}
```

#### 3.2.2 Google Places API Response

```swift
struct GooglePlacesResponse: Codable {
    let results: [PlaceResult]
    let status: String
    let nextPageToken: String?
}

struct PlaceResult: Codable {
    let placeId: String
    let name: String
    let geometry: PlaceGeometry
    let vicinity: String
    let types: [String]
    let rating: Double?
    let priceLevel: Int?
    let photos: [PlacePhoto]?
    let openingHours: OpeningHours?
    
    private enum CodingKeys: String, CodingKey {
        case placeId = "place_id"
        case name, geometry, vicinity, types, rating
        case priceLevel = "price_level"
        case photos
        case openingHours = "opening_hours"
    }
}
```

---

## 4. ユースケース設計

### 4.1 PlaceRecommendationUseCase

```swift
protocol PlaceRecommendationUseCase {
    func getRecommendations(
        currentLocation: CLLocationCoordinate2D,
        destination: CLLocationCoordinate2D,
        mood: Mood,
        transportMode: TransportMode
    ) async throws -> [Genre]
}

class PlaceRecommendationUseCaseImpl: PlaceRecommendationUseCase {
    private let aiRepository: AIRecommendationRepository
    private let placeRepository: PlaceRepository
    private let cacheRepository: CacheRepository
    
    func getRecommendations(
        currentLocation: CLLocationCoordinate2D,
        destination: CLLocationCoordinate2D,
        mood: Mood,
        transportMode: TransportMode
    ) async throws -> [Genre] {
        // 1. キャッシュから除外リストを取得
        let excludedPlaceIds = await cacheRepository.getExcludedPlaceIds()
        
        // 2. OpenAI APIで推薦を取得
        let aiRecommendations = try await aiRepository.getRecommendations(
            request: OpenAIRecommendationRequest(
                currentLocation: currentLocation,
                destination: destination,
                currentTime: Date(),
                mood: mood,
                transportMode: transportMode,
                excludedPlaceIds: excludedPlaceIds
            )
        )
        
        // 3. Google Places APIで実在性を確認
        var validPlaces: [Place] = []
        for recommendation in aiRecommendations {
            if let place = try await placeRepository.searchPlace(name: recommendation) {
                validPlaces.append(place)
            }
        }
        
        // 4. 3件に満たない場合は追加検索
        if validPlaces.count < 3 {
            let additionalPlaces = try await searchAdditionalPlaces(
                location: currentLocation,
                mood: mood,
                needed: 3 - validPlaces.count,
                excludeIds: validPlaces.map { $0.id }
            )
            validPlaces.append(contentsOf: additionalPlaces)
        }
        
        // 5. 候補なしの場合
        if validPlaces.isEmpty {
            throw PlaceRecommendationError.noValidPlaces
        }
        
        // 6. ジャンル情報のみ返却（スポット名は隠匿）
        let genres = validPlaces.map { place in
            Genre(
                id: UUID().uuidString,
                name: place.genre.name,
                category: place.genre.category,
                googleMapType: place.genre.googleMapType
            )
        }
        
        // 7. 提案したスポットをキャッシュに保存
        await cacheRepository.savePlacesForGenres(places: validPlaces, genres: genres)
        
        return Array(genres.prefix(3))
    }
}
```

### 4.2 NavigationUseCase

```swift
protocol NavigationUseCase {
    func startNavigation(
        origin: CLLocationCoordinate2D,
        destination: CLLocationCoordinate2D,
        selectedGenre: Genre,
        transportMode: TransportMode
    ) async throws -> NavigationRoute
    
    func checkArrival(
        currentLocation: CLLocationCoordinate2D,
        waypoint: Place
    ) -> Bool
}

class NavigationUseCaseImpl: NavigationUseCase {
    private let cacheRepository: CacheRepository
    private let locationRepository: LocationRepository
    
    func startNavigation(
        origin: CLLocationCoordinate2D,
        destination: CLLocationCoordinate2D,
        selectedGenre: Genre,
        transportMode: TransportMode
    ) async throws -> NavigationRoute {
        // 1. キャッシュから選択されたジャンルに対応するスポットを取得
        guard let waypoint = await cacheRepository.getPlaceForGenre(genre: selectedGenre) else {
            throw NavigationError.waypointNotFound
        }
        
        // 2. ナビゲーション経路を作成
        let route = NavigationRoute(
            id: UUID(),
            origin: origin,
            destination: destination,
            waypoint: waypoint,
            transportMode: transportMode,
            totalDistance: 0, // Google Directions APIで取得
            estimatedDuration: 0, // Google Directions APIで取得
            polyline: "", // Google Directions APIで取得
            createdAt: Date()
        )
        
        // 3. Google Maps アプリで経路案内開始
        try await locationRepository.startGoogleMapsNavigation(route: route)
        
        return route
    }
    
    func checkArrival(
        currentLocation: CLLocationCoordinate2D,
        waypoint: Place
    ) -> Bool {
        let distance = CLLocation(
            latitude: currentLocation.latitude,
            longitude: currentLocation.longitude
        ).distance(from: CLLocation(
            latitude: waypoint.coordinate.latitude,
            longitude: waypoint.coordinate.longitude
        ))
        
        // 半径50m以内で到着とみなす
        return distance <= 50.0
    }
}
```

---

## 5. UI/UX設計

### 5.1 画面遷移図

```
起動
  ↓
ホーム画面 ──→ 目的地設定画面
  ↓                ↓
移動手段選択 ←──────┘
  ↓
気分選択画面
  ↓
ジャンル選択画面
  ↓
ナビゲーション開始
  ↓
到着検知・スポット名表示
```

### 5.2 各画面の詳細設計

#### 5.2.1 ホーム画面（HomeView）

**目的**: アプリの開始点として、ユーザーにアプリの目的を伝える

**レイアウト**:
```
┌─────────────────────────┐
│    まっすぐ帰りたくない    │
│                         │
│    🗺️ 今日はどこへ？     │
│                         │
│  ┌─────────────────┐    │
│  │  目的地を設定する  │    │
│  └─────────────────┘    │
│                         │
│    現在地: 東京駅         │
└─────────────────────────┘
```

**コンポーネント**:
- アプリタイトル
- メイン画像/アイコン
- 「目的地を設定する」ボタン
- 現在地表示

#### 5.2.2 目的地設定画面（DestinationSettingView）

**目的**: 目的地を地図またはテキストで設定

**レイアウト**:
```
┌─────────────────────────┐
│      目的地を設定        │
│                         │
│  ┌─────────────────┐    │
│  │                 │    │
│  │    MapView      │    │
│  │                 │    │
│  └─────────────────┘    │
│                         │
│  ┌─────────────────┐    │
│  │ 🔍 目的地を検索   │    │
│  └─────────────────┘    │
│                         │
│  ┌─────────────────┐    │
│  │     次へ        │    │
│  └─────────────────┘    │
└─────────────────────────┘
```

**機能**:
- 地図タップで目的地設定
- 検索バーでテキスト入力
- 目的地確定後、次の画面へ遷移

#### 5.2.3 移動手段選択画面（TransportModeView）

**目的**: 移動手段を選択

**レイアウト**:
```
┌─────────────────────────┐
│      移動手段を選択       │
│                         │
│  🚶‍♂️ 徒歩   🚗 車        │
│                         │
│  🚇 電車   🚴‍♂️ 自転車    │
│                         │
│  ┌─────────────────┐    │
│  │     次へ        │    │
│  └─────────────────┘    │
└─────────────────────────┘
```

#### 5.2.4 気分選択画面（MoodSelectionView）

**目的**: ユーザーの現在の気分を選択（グループごとの排他制御）

**レイアウト**:
```
┌─────────────────────────┐
│     今の気分は？         │
│                         │
│  アクティビティタイプ      │
│  ┌─────┐  ┌─────┐      │
│  │インドア│  │アウトドア│     │
│  └─────┘  └─────┘      │
│                         │
│  バイブタイプ            │
│  ┌─────┐┌─────┐┌─────┐ │
│  │Jazzy││発見！││ワクワク│ │
│  └─────┘└─────┘└─────┘ │
│                         │
│  ┌─────────────────┐    │
│  │     次へ        │    │
│  └─────────────────┘    │
└─────────────────────────┘
```

**制約**:
- アクティビティタイプは排他選択（インドア OR アウトドア）
- バイブタイプも排他選択（Jazzy OR 発見！ OR ワクワク）

#### 5.2.5 ジャンル選択画面（GenreSelectionView）

**目的**: AIが提案した3つのジャンルから1つを選択

**レイアウト**:
```
┌─────────────────────────┐
│    どのジャンルにする？   │
│                         │
│  ┌─────────────────┐    │
│  │     カフェ       │    │
│  └─────────────────┘    │
│                         │
│  ┌─────────────────┐    │
│  │     公園        │    │
│  └─────────────────┘    │
│                         │
│  ┌─────────────────┐    │
│  │    博物館       │    │
│  └─────────────────┘    │
│                         │
│                         │
│ ※スポット名は到着まで秘密！│
└─────────────────────────┘
```

**注意**:
- スポット名は表示しない
- ジャンル名のみ表示
- 3つの選択肢を提示

#### 5.2.6 ナビゲーション画面（NavigationView）

**目的**: Google Mapsアプリでの経路案内と到着検知

**レイアウト**:
```
┌─────────────────────────┐
│    経路案内開始！        │
│                         │
│  Google Mapsアプリで     │
│  ナビゲーションが開始     │
│  されます               │
│                         │
│  選択ジャンル: カフェ      │
│                         │
│  🎯 到着をお待ちください   │
│                         │
│  ┌─────────────────┐    │
│  │ Google Maps起動  │    │
│  └─────────────────┘    │
└─────────────────────────┘
```

#### 5.2.7 到着画面（ArrivalView）

**目的**: 経由地到着時にスポット名を解禁

**レイアウト**:
```
┌─────────────────────────┐
│      🎉 到着！          │
│                         │
│    今回の寄り道先は      │
│                         │
│  ┌─────────────────┐    │
│  │                 │    │
│  │  スターバックス   │    │
│  │   渋谷店        │    │
│  │                 │    │
│  └─────────────────┘    │
│                         │
│   素敵な寄り道を！       │
│                         │
│  ┌─────────────────┐    │
│  │    完了         │    │
│  └─────────────────┘    │
└─────────────────────────┘
```

---

## 6. API設計

### 6.1 OpenAI API連携

#### 6.1.1 リクエスト仕様

```swift
struct OpenAIRequest {
    let model: String = "gpt-4"
    let messages: [ChatMessage]
    let maxTokens: Int = 1000
    let temperature: Double = 0.7
}

struct ChatMessage {
    let role: String // "system", "user"
    let content: String
}

// システムプロンプト例
let systemPrompt = """
あなたは経由地推薦の専門家です。
以下の条件に基づいて、ユーザーの移動経路上にある興味深いスポットを3つ推薦してください。

制約:
1. 飲食店を30%、それ以外を70%の割合で含める
2. 現在地と目的地の間にある実在するスポットのみ
3. 除外リストに含まれるスポットは避ける
4. 気分と移動手段を考慮する
5. GooglePlaces APIで検索可能な具体的な名称で回答する

回答形式:
[
  {
    "name": "具体的なスポット名",
    "category": "restaurant" or "other",
    "reason": "推薦理由"
  }
]
"""
```

#### 6.1.2 レスポンス処理

```swift
struct OpenAIResponse: Codable {
    let choices: [Choice]
    
    struct Choice: Codable {
        let message: ChatMessage
        let finishReason: String?
        
        private enum CodingKeys: String, CodingKey {
            case message
            case finishReason = "finish_reason"
        }
    }
}

struct RecommendationResult: Codable {
    let name: String
    let category: String
    let reason: String
}
```

### 6.2 Google Places API連携

#### 6.2.1 Places Search API

```swift
// リクエストURL例
// https://maps.googleapis.com/maps/api/place/textsearch/json?query={スポット名}&location={緯度},{経度}&radius={半径}&key={APIキー}

struct GooglePlacesSearchRequest {
    let query: String
    let location: CLLocationCoordinate2D
    let radius: Int = 5000 // 5km
    let type: String?
    let apiKey: String
    
    var url: URL? {
        var components = URLComponents(string: "https://maps.googleapis.com/maps/api/place/textsearch/json")
        components?.queryItems = [
            URLQueryItem(name: "query", value: query),
            URLQueryItem(name: "location", value: "\(location.latitude),\(location.longitude)"),
            URLQueryItem(name: "radius", value: "\(radius)"),
            URLQueryItem(name: "key", value: apiKey)
        ]
        
        if let type = type {
            components?.queryItems?.append(URLQueryItem(name: "type", value: type))
        }
        
        return components?.url
    }
}
```

#### 6.2.2 Place Details API

```swift
struct GooglePlaceDetailsRequest {
    let placeId: String
    let fields: [String] = [
        "name", "formatted_address", "geometry", "types",
        "rating", "price_level", "photos", "opening_hours"
    ]
    let apiKey: String
    
    var url: URL? {
        var components = URLComponents(string: "https://maps.googleapis.com/maps/api/place/details/json")
        components?.queryItems = [
            URLQueryItem(name: "place_id", value: placeId),
            URLQueryItem(name: "fields", value: fields.joined(separator: ",")),
            URLQueryItem(name: "key", value: apiKey)
        ]
        return components?.url
    }
}
```

### 6.3 Google Directions API連携

```swift
struct GoogleDirectionsRequest {
    let origin: CLLocationCoordinate2D
    let destination: CLLocationCoordinate2D
    let waypoints: [CLLocationCoordinate2D]
    let mode: TransportMode
    let apiKey: String
    
    var url: URL? {
        var components = URLComponents(string: "https://maps.googleapis.com/maps/api/directions/json")
        let waypointsString = waypoints.map { "\($0.latitude),\($0.longitude)" }.joined(separator: "|")
        
        components?.queryItems = [
            URLQueryItem(name: "origin", value: "\(origin.latitude),\(origin.longitude)"),
            URLQueryItem(name: "destination", value: "\(destination.latitude),\(destination.longitude)"),
            URLQueryItem(name: "waypoints", value: waypointsString),
            URLQueryItem(name: "mode", value: mode.rawValue),
            URLQueryItem(name: "key", value: apiKey)
        ]
        return components?.url
    }
}
```

---

## 7. テスト設計（TDD）

### 7.1 テスト戦略

#### 7.1.1 テストピラミッド

```
        ┌─────────────┐
        │    UI Tests │ ← 少数
        └─────────────┘
      ┌─────────────────┐
      │ Integration Tests│ ← 中程度
      └─────────────────┘
    ┌─────────────────────┐
    │    Unit Tests       │ ← 多数
    └─────────────────────┘
```

#### 7.1.2 テストカバレッジ目標

- Unit Tests: 90%以上
- Integration Tests: 70%以上
- UI Tests: 主要フロー100%

### 7.2 Unit Tests

#### 7.2.1 MoodSelectionUseCaseTests

```swift
class MoodSelectionUseCaseTests: XCTestCase {
    var useCase: MoodSelectionUseCase!
    
    override func setUp() {
        super.setUp()
        useCase = MoodSelectionUseCaseImpl()
    }
    
    func test_気分選択_アクティビティタイプの排他制御() {
        // Given
        let mood = Mood(activityType: .indoor, vibeType: .jazzy)
        
        // When
        let result = useCase.validateMoodSelection(mood)
        
        // Then
        XCTAssertTrue(result.isValid)
        XCTAssertEqual(result.mood.activityType, .indoor)
        XCTAssertEqual(result.mood.vibeType, .jazzy)
    }
    
    func test_気分選択_無効な組み合わせの検証() {
        // Given
        let invalidMood = Mood(activityType: .indoor, vibeType: .outdoor) // 無効な組み合わせ
        
        // When
        let result = useCase.validateMoodSelection(invalidMood)
        
        // Then
        XCTAssertFalse(result.isValid)
        XCTAssertNotNil(result.error)
    }
}
```

#### 7.2.2 PlaceRecommendationUseCaseTests

```swift
class PlaceRecommendationUseCaseTests: XCTestCase {
    var useCase: PlaceRecommendationUseCase!
    var mockAIRepository: MockAIRecommendationRepository!
    var mockPlaceRepository: MockPlaceRepository!
    var mockCacheRepository: MockCacheRepository!
    
    override func setUp() {
        super.setUp()
        mockAIRepository = MockAIRecommendationRepository()
        mockPlaceRepository = MockPlaceRepository()
        mockCacheRepository = MockCacheRepository()
        
        useCase = PlaceRecommendationUseCaseImpl(
            aiRepository: mockAIRepository,
            placeRepository: mockPlaceRepository,
            cacheRepository: mockCacheRepository
        )
    }
    
    func test_推薦取得_正常ケース() async throws {
        // Given
        let currentLocation = CLLocationCoordinate2D(latitude: 35.6812, longitude: 139.7671)
        let destination = CLLocationCoordinate2D(latitude: 35.6895, longitude: 139.6917)
        let mood = Mood(activityType: .outdoor, vibeType: .exciting)
        let transportMode = TransportMode.walking
        
        mockAIRepository.recommendationsToReturn = [
            "スターバックス渋谷店",
            "代々木公園",
            "明治神宮"
        ]
        
        mockPlaceRepository.placesToReturn = [
            Place(id: "1", name: "スターバックス渋谷店", genre: Genre(category: .restaurant)),
            Place(id: "2", name: "代々木公園", genre: Genre(category: .other)),
            Place(id: "3", name: "明治神宮", genre: Genre(category: .other))
        ]
        
        // When
        let genres = try await useCase.getRecommendations(
            currentLocation: currentLocation,
            destination: destination,
            mood: mood,
            transportMode: transportMode
        )
        
        // Then
        XCTAssertEqual(genres.count, 3)
        XCTAssertEqual(genres.filter { $0.category == .restaurant }.count, 1) // 30%
        XCTAssertEqual(genres.filter { $0.category == .other }.count, 2) // 70%
    }
    
    func test_推薦取得_候補なしケース() async {
        // Given
        mockAIRepository.recommendationsToReturn = []
        mockPlaceRepository.placesToReturn = []
        
        // When & Then
        do {
            let _ = try await useCase.getRecommendations(
                currentLocation: CLLocationCoordinate2D(latitude: 0, longitude: 0),
                destination: CLLocationCoordinate2D(latitude: 0, longitude: 0),
                mood: Mood(activityType: .indoor, vibeType: .jazzy),
                transportMode: .walking
            )
            XCTFail("例外が発生すべき")
        } catch {
            XCTAssertTrue(error is PlaceRecommendationError)
            XCTAssertEqual(error as? PlaceRecommendationError, .noValidPlaces)
        }
    }
}
```

### 7.3 Integration Tests

#### 7.3.1 API連携テスト

```swift
class APIIntegrationTests: XCTestCase {
    var apiClient: OpenAIAPIClient!
    
    override func setUp() {
        super.setUp()
        apiClient = OpenAIAPIClient(apiKey: "test_api_key")
    }
    
    func test_OpenAI_API呼び出し() async throws {
        // Given
        let request = OpenAIRecommendationRequest(
            currentLocation: CLLocationCoordinate2D(latitude: 35.6812, longitude: 139.7671),
            destination: CLLocationCoordinate2D(latitude: 35.6895, longitude: 139.6917),
            currentTime: Date(),
            mood: Mood(activityType: .outdoor, vibeType: .exciting),
            transportMode: .walking,
            excludedPlaceIds: []
        )
        
        // When
        let response = try await apiClient.getRecommendations(request: request)
        
        // Then
        XCTAssertFalse(response.isEmpty)
        XCTAssertLessThanOrEqual(response.count, 3)
    }
}
```

### 7.4 UI Tests

#### 7.4.1 メインフローのテスト

```swift
class MainFlowUITests: XCTestCase {
    var app: XCUIApplication!
    
    override func setUp() {
        super.setUp()
        app = XCUIApplication()
        app.launch()
    }
    
    func test_メインフロー_目的地設定から到着まで() {
        // ホーム画面
        let destinationButton = app.buttons["目的地を設定する"]
        XCTAssertTrue(destinationButton.exists)
        destinationButton.tap()
        
        // 目的地設定画面
        let searchField = app.textFields["目的地を検索"]
        searchField.tap()
        searchField.typeText("渋谷駅")
        
        let nextButton = app.buttons["次へ"]
        nextButton.tap()
        
        // 移動手段選択画面
        let walkingButton = app.buttons["徒歩"]
        walkingButton.tap()
        nextButton.tap()
        
        // 気分選択画面
        let outdoorButton = app.buttons["アウトドア"]
        let excitingButton = app.buttons["ワクワク"]
        outdoorButton.tap()
        excitingButton.tap()
        nextButton.tap()
        
        // ジャンル選択画面（モック応答想定）
        let genreButton = app.buttons.element(boundBy: 0) // 最初のジャンル
        XCTAssertTrue(genreButton.exists)
        genreButton.tap()
        
        // ナビゲーション画面
        let googleMapsButton = app.buttons["Google Maps起動"]
        XCTAssertTrue(googleMapsButton.exists)
    }
    
    func test_気分選択_排他制御() {
        // 気分選択画面まで遷移
        navigateToMoodSelection()
        
        // インドアを選択
        let indoorButton = app.buttons["インドア"]
        indoorButton.tap()
        XCTAssertTrue(indoorButton.isSelected)
        
        // アウトドアを選択（インドアは自動で非選択になる）
        let outdoorButton = app.buttons["アウトドア"]
        outdoorButton.tap()
        XCTAssertTrue(outdoorButton.isSelected)
        XCTAssertFalse(indoorButton.isSelected)
        
        // バイブタイプの排他制御
        let jazzyButton = app.buttons["Jazzy"]
        let discoveryButton = app.buttons["発見！"]
        
        jazzyButton.tap()
        XCTAssertTrue(jazzyButton.isSelected)
        
        discoveryButton.tap()
        XCTAssertTrue(discoveryButton.isSelected)
        XCTAssertFalse(jazzyButton.isSelected)
    }
}
```

---

## 8. セキュリティ設計

### 8.1 APIキー管理

#### 8.1.1 環境変数管理

```swift
// Config/Environment.swift
enum Environment {
    enum Keys {
        static let openAIAPIKey = "OPENAI_API_KEY"
        static let googleMapsAPIKey = "GOOGLE_MAPS_API_KEY"
        static let googlePlacesAPIKey = "GOOGLE_PLACES_API_KEY"
    }
    
    static func value(for key: String) -> String {
        guard let value = Bundle.main.infoDictionary?[key] as? String else {
            fatalError("環境変数 \(key) が設定されていません")
        }
        return value
    }
}

// 使用例
let openAIAPIKey = Environment.value(for: Environment.Keys.openAIAPIKey)
```

#### 8.1.2 Info.plist設定

```xml
<!-- Info.plist -->
<dict>
    <key>OPENAI_API_KEY</key>
    <string>$(OPENAI_API_KEY)</string>
    <key>GOOGLE_MAPS_API_KEY</key>
    <string>$(GOOGLE_MAPS_API_KEY)</string>
    <key>GOOGLE_PLACES_API_KEY</key>
    <string>$(GOOGLE_PLACES_API_KEY)</string>
</dict>
```

### 8.2 位置情報のプライバシー

#### 8.2.1 位置情報の利用許可

```xml
<!-- Info.plist -->
<key>NSLocationWhenInUseUsageDescription</key>
<string>現在地から目的地への最適な経由地を提案するために位置情報を使用します。</string>
<key>NSLocationAlwaysAndWhenInUseUsageDescription</key>
<string>経由地への到着を検知するために位置情報を使用します。</string>
```

#### 8.2.2 位置情報の取り扱い

```swift
class LocationManager: NSObject, ObservableObject {
    private let manager = CLLocationManager()
    
    override init() {
        super.init()
        manager.delegate = self
        manager.desiredAccuracy = kCLLocationAccuracyBest
    }
    
    func requestPermission() {
        switch manager.authorizationStatus {
        case .notDetermined:
            manager.requestWhenInUseAuthorization()
        case .denied, .restricted:
            // 設定画面への誘導
            showLocationPermissionAlert()
        default:
            break
        }
    }
    
    private func showLocationPermissionAlert() {
        // 位置情報許可を促すアラート表示
    }
}
```

### 8.3 データの保護

#### 8.3.1 キャッシュデータの暗号化

```swift
class SecureCacheRepository: CacheRepository {
    private let keychain = Keychain(service: "com.app.dontgohomestraight")
    
    func saveExcludedPlaceIds(_ placeIds: [String]) async {
        let data = try? JSONEncoder().encode(placeIds)
        let encryptedData = encrypt(data: data)
        keychain["excluded_places"] = encryptedData
    }
    
    func getExcludedPlaceIds() async -> [String] {
        guard let encryptedData = keychain["excluded_places"],
              let data = decrypt(data: encryptedData),
              let placeIds = try? JSONDecoder().decode([String].self, from: data) else {
            return []
        }
        return placeIds
    }
    
    private func encrypt(data: Data?) -> String {
        // AES暗号化実装
    }
    
    private func decrypt(data: String) -> Data? {
        // AES復号化実装
    }
}
```

---

## 9. エラーハンドリング設計

### 9.1 エラー定義

```swift
enum AppError: LocalizedError {
    case networkError(NetworkError)
    case locationError(LocationError)
    case placeRecommendationError(PlaceRecommendationError)
    case navigationError(NavigationError)
    case validationError(ValidationError)
    
    var errorDescription: String? {
        switch self {
        case .networkError(let error):
            return error.localizedDescription
        case .locationError(let error):
            return error.localizedDescription
        case .placeRecommendationError(let error):
            return error.localizedDescription
        case .navigationError(let error):
            return error.localizedDescription
        case .validationError(let error):
            return error.localizedDescription
        }
    }
}

enum NetworkError: LocalizedError {
    case noInternet
    case timeout
    case invalidResponse
    case apiKeyInvalid
    case rateLimitExceeded
    
    var errorDescription: String? {
        switch self {
        case .noInternet:
            return "インターネット接続を確認してください"
        case .timeout:
            return "通信がタイムアウトしました"
        case .invalidResponse:
            return "サーバーからの応答が無効です"
        case .apiKeyInvalid:
            return "APIキーが無効です"
        case .rateLimitExceeded:
            return "API利用制限に達しました。しばらく待ってから再度お試しください"
        }
    }
}

enum PlaceRecommendationError: LocalizedError {
    case noValidPlaces
    case aiServiceUnavailable
    case placesAPIError
    
    var errorDescription: String? {
        switch self {
        case .noValidPlaces:
            return "候補地がありません。今日はまっすぐ帰りましょう🎵"
        case .aiServiceUnavailable:
            return "AI推薦サービスが一時的に利用できません"
        case .placesAPIError:
            return "場所検索サービスでエラーが発生しました"
        }
    }
}
```

### 9.2 エラーハンドリング戦略

#### 9.2.1 リトライ機能

```swift
class NetworkManager {
    func request<T: Codable>(_ request: URLRequest, type: T.Type) async throws -> T {
        let maxRetries = 3
        var lastError: Error?
        
        for attempt in 1...maxRetries {
            do {
                let (data, response) = try await URLSession.shared.data(for: request)
                
                guard let httpResponse = response as? HTTPURLResponse else {
                    throw NetworkError.invalidResponse
                }
                
                switch httpResponse.statusCode {
                case 200...299:
                    return try JSONDecoder().decode(T.self, from: data)
                case 429:
                    // Rate limit exceeded - exponential backoff
                    let delay = pow(2.0, Double(attempt))
                    try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                    continue
                case 401:
                    throw NetworkError.apiKeyInvalid
                default:
                    throw NetworkError.invalidResponse
                }
            } catch {
                lastError = error
                if attempt == maxRetries {
                    break
                }
                
                // Exponential backoff for retries
                let delay = pow(2.0, Double(attempt))
                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
            }
        }
        
        throw lastError ?? NetworkError.invalidResponse
    }
}
```

#### 9.2.2 ユーザーフレンドリーなエラー表示

```swift
struct ErrorView: View {
    let error: AppError
    let retryAction: (() -> Void)?
    
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: errorIcon)
                .font(.system(size: 64))
                .foregroundColor(.red)
            
            Text(error.localizedDescription)
                .font(.headline)
                .multilineTextAlignment(.center)
            
            if let retryAction = retryAction {
                Button("再試行") {
                    retryAction()
                }
                .buttonStyle(.borderedProminent)
            }
        }
        .padding()
    }
    
    private var errorIcon: String {
        switch error {
        case .networkError:
            return "wifi.exclamationmark"
        case .locationError:
            return "location.slash"
        case .placeRecommendationError:
            return "questionmark.circle"
        case .navigationError:
            return "map.circle"
        case .validationError:
            return "exclamationmark.triangle"
        }
    }
}
```

---

## 10. パフォーマンス設計

### 10.1 キャッシュ戦略

#### 10.1.1 マルチレベルキャッシュ

```swift
protocol CacheRepository {
    func savePlace(_ place: Place, for genre: Genre) async
    func getPlace(for genre: Genre) async -> Place?
    func saveExcludedPlaceIds(_ placeIds: [String]) async
    func getExcludedPlaceIds() async -> [String]
    func clearCache() async
}

class CacheRepositoryImpl: CacheRepository {
    private let memoryCache = NSCache<NSString, NSData>()
    private let diskCache: DiskCache
    private let keychain: Keychain
    
    init() {
        diskCache = DiskCache()
        keychain = Keychain(service: "com.app.dontgohomestraight")
        
        // メモリキャッシュの設定
        memoryCache.countLimit = 100
        memoryCache.totalCostLimit = 10 * 1024 * 1024 // 10MB
    }
    
    func savePlace(_ place: Place, for genre: Genre) async {
        let key = "place_\(genre.id)"
        let data = try? JSONEncoder().encode(place)
        
        // メモリキャッシュ
        if let data = data {
            memoryCache.setObject(data as NSData, forKey: key as NSString)
        }
        
        // ディスクキャッシュ
        await diskCache.save(data, for: key)
    }
    
    func getPlace(for genre: Genre) async -> Place? {
        let key = "place_\(genre.id)"
        
        // メモリキャッシュから取得
        if let data = memoryCache.object(forKey: key as NSString) {
            return try? JSONDecoder().decode(Place.self, from: data as Data)
        }
        
        // ディスクキャッシュから取得
        if let data = await diskCache.load(for: key) {
            let place = try? JSONDecoder().decode(Place.self, from: data)
            
            // メモリキャッシュに保存
            if let place = place {
                memoryCache.setObject(data as NSData, forKey: key as NSString)
            }
            
            return place
        }
        
        return nil
    }
}
```

#### 10.1.2 画像キャッシュ

```swift
class ImageCacheManager: ObservableObject {
    static let shared = ImageCacheManager()
    private let cache = NSCache<NSString, UIImage>()
    private let fileManager = FileManager.default
    
    init() {
        cache.countLimit = 100
        cache.totalCostLimit = 50 * 1024 * 1024 // 50MB
    }
    
    func image(for url: URL) async -> UIImage? {
        let key = url.absoluteString as NSString
        
        // メモリキャッシュから取得
        if let cachedImage = cache.object(forKey: key) {
            return cachedImage
        }
        
        // ディスクキャッシュから取得
        if let cachedImage = loadImageFromDisk(for: url) {
            cache.setObject(cachedImage, forKey: key)
            return cachedImage
        }
        
        // ネットワークから取得
        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            guard let image = UIImage(data: data) else { return nil }
            
            // キャッシュに保存
            cache.setObject(image, forKey: key)
            saveImageToDisk(image, for: url)
            
            return image
        } catch {
            return nil
        }
    }
    
    private func loadImageFromDisk(for url: URL) -> UIImage? {
        let filename = url.lastPathComponent
        let filePath = getCacheDirectory().appendingPathComponent(filename)
        return UIImage(contentsOfFile: filePath.path)
    }
    
    private func saveImageToDisk(_ image: UIImage, for url: URL) {
        guard let data = image.jpegData(compressionQuality: 0.8) else { return }
        let filename = url.lastPathComponent
        let filePath = getCacheDirectory().appendingPathComponent(filename)
        try? data.write(to: filePath)
    }
    
    private func getCacheDirectory() -> URL {
        return fileManager.urls(for: .cachesDirectory, in: .userDomainMask)[0]
    }
}
```

### 10.2 非同期処理の最適化

#### 10.2.1 並列処理による高速化

```swift
class PlaceRecommendationService {
    func getRecommendations(request: RecommendationRequest) async throws -> [Genre] {
        // 並列でAPI呼び出し実行
        async let aiRecommendations = aiRepository.getRecommendations(request: request)
        async let nearbyPlaces = placeRepository.getNearbyPlaces(
            location: request.currentLocation,
            radius: 5000
        )
        async let excludedPlaces = cacheRepository.getExcludedPlaceIds()
        
        // 結果を待機
        let (recommendations, nearby, excluded) = try await (
            aiRecommendations,
            nearbyPlaces,
            excludedPlaces
        )
        
        // フィルタリングと検証を並列実行
        let validationTasks = recommendations.map { recommendation in
            Task {
                return await validatePlace(recommendation: recommendation, nearbyPlaces: nearby)
            }
        }
        
        var validPlaces: [Place] = []
        for task in validationTasks {
            if let place = await task.value {
                validPlaces.append(place)
            }
        }
        
        return generateGenres(from: validPlaces)
    }
}
```

#### 10.2.2 プリロード戦略

```swift
class PreloadManager {
    private let locationManager: LocationManager
    private let placeRepository: PlaceRepository
    
    func startPreloading() {
        Task {
            await preloadNearbyPlaces()
            await preloadCommonGenres()
        }
    }
    
    private func preloadNearbyPlaces() async {
        guard let currentLocation = locationManager.currentLocation else { return }
        
        // よく使われるカテゴリの場所を事前に取得
        let commonTypes = ["restaurant", "tourist_attraction", "park", "museum", "cafe"]
        
        await withTaskGroup(of: Void.self) { group in
            for type in commonTypes {
                group.addTask {
                    let _ = try? await self.placeRepository.searchPlaces(
                        location: currentLocation,
                        type: type,
                        radius: 3000
                    )
                }
            }
        }
    }
    
    private func preloadCommonGenres() async {
        // よく選ばれるジャンルの情報を事前に準備
        let commonGenres = [
            Genre(name: "カフェ", category: .restaurant),
            Genre(name: "公園", category: .other),
            Genre(name: "美術館", category: .other)
        ]
        
        for genre in commonGenres {
            await cacheRepository.preloadGenreData(genre)
        }
    }
}
```

---

## 11. 運用・監視設計

### 11.1 ログ設計

#### 11.1.1 ログレベルとカテゴリ

```swift
enum LogLevel: String {
    case debug = "DEBUG"
    case info = "INFO"
    case warning = "WARNING"
    case error = "ERROR"
    case critical = "CRITICAL"
}

enum LogCategory: String {
    case ui = "UI"
    case api = "API"
    case location = "LOCATION"
    case navigation = "NAVIGATION"
    case cache = "CACHE"
    case security = "SECURITY"
}

class Logger {
    static let shared = Logger()
    
    func log(_ message: String, level: LogLevel, category: LogCategory, file: String = #file, function: String = #function, line: Int = #line) {
        let timestamp = DateFormatter.logFormatter.string(from: Date())
        let filename = URL(fileURLWithPath: file).lastPathComponent
        
        let logMessage = "[\(timestamp)] [\(level.rawValue)] [\(category.rawValue)] \(filename):\(line) \(function) - \(message)"
        
        #if DEBUG
        print(logMessage)
        #endif
        
        // 本番環境では適切なログサービスに送信
        if level == .error || level == .critical {
            sendToRemoteLogging(logMessage)
        }
    }
    
    private func sendToRemoteLogging(_ message: String) {
        // Crashlytics、Sentry等への送信
    }
}

// 使用例
extension Logger {
    func logAPICall(_ url: String, statusCode: Int) {
        log("API呼び出し: \(url), ステータス: \(statusCode)", level: .info, category: .api)
    }
    
    func logLocationUpdate(_ location: CLLocation) {
        log("位置情報更新: \(location.coordinate)", level: .debug, category: .location)
    }
    
    func logError(_ error: Error, context: String) {
        log("エラー発生: \(error.localizedDescription), コンテキスト: \(context)", level: .error, category: .ui)
    }
}
```

### 11.2 パフォーマンス監視

#### 11.2.1 メトリクス収集

```swift
class PerformanceMonitor {
    static let shared = PerformanceMonitor()
    
    func measureExecutionTime<T>(
        operation: String,
        category: LogCategory,
        execute: () async throws -> T
    ) async rethrows -> T {
        let startTime = CFAbsoluteTimeGetCurrent()
        let result = try await execute()
        let executionTime = CFAbsoluteTimeGetCurrent() - startTime
        
        Logger.shared.log(
            "実行時間: \(operation) - \(String(format: "%.3f", executionTime))秒",
            level: .info,
            category: category
        )
        
        // メトリクス送信
        sendMetric(operation: operation, duration: executionTime)
        
        return result
    }
    
    private func sendMetric(operation: String, duration: TimeInterval) {
        // Analytics service への送信
        #if !DEBUG
        // Firebase Analytics, Mixpanel等
        #endif
    }
}

// 使用例
let places = await PerformanceMonitor.shared.measureExecutionTime(
    operation: "AI推薦取得",
    category: .api
) {
    try await aiRepository.getRecommendations(request: request)
}
```

### 11.3 クラッシュレポート

#### 11.3.1 Crashlytics連携

```swift
import FirebaseCrashlytics

class CrashReporter {
    static let shared = CrashReporter()
    
    func recordError(_ error: Error, additionalInfo: [String: Any] = [:]) {
        #if !DEBUG
        Crashlytics.crashlytics().record(error: error)
        
        for (key, value) in additionalInfo {
            Crashlytics.crashlytics().setCustomValue(value, forKey: key)
        }
        #endif
    }
    
    func setUserInfo(userId: String?) {
        #if !DEBUG
        Crashlytics.crashlytics().setUserID(userId)
        #endif
    }
    
    func logBreadcrumb(_ message: String) {
        #if !DEBUG
        Crashlytics.crashlytics().log(message)
        #endif
    }
}
```

---

## 12. 設定・環境管理

### 12.1 設定ファイル構成

#### 12.1.1 開発環境別設定

```
Config/
├── Development.xcconfig
├── Staging.xcconfig
├── Production.xcconfig
└── Base.xcconfig
```

```
// Base.xcconfig
APP_NAME = まっすぐ帰りたくない
BUNDLE_ID_PREFIX = com.app.dontgohomestraight

// Development.xcconfig
#include "Base.xcconfig"
APP_NAME = $(APP_NAME) Dev
BUNDLE_IDENTIFIER = $(BUNDLE_ID_PREFIX).dev
API_BASE_URL = https://api-dev.example.com

// Production.xcconfig
#include "Base.xcconfig"
BUNDLE_IDENTIFIER = $(BUNDLE_ID_PREFIX)
API_BASE_URL = https://api.example.com
```

#### 12.1.2 環境変数管理

```swift
enum BuildConfiguration {
    case debug
    case staging
    case release
    
    static var current: BuildConfiguration {
        #if DEBUG
        return .debug
        #elseif STAGING
        return .staging
        #else
        return .release
        #endif
    }
}

struct AppConfiguration {
    static let shared = AppConfiguration()
    
    let apiTimeout: TimeInterval
    let cacheSize: Int
    let logLevel: LogLevel
    let isAnalyticsEnabled: Bool
    
    private init() {
        switch BuildConfiguration.current {
        case .debug:
            apiTimeout = 60.0
            cacheSize = 50 * 1024 * 1024 // 50MB
            logLevel = .debug
            isAnalyticsEnabled = false
            
        case .staging:
            apiTimeout = 30.0
            cacheSize = 100 * 1024 * 1024 // 100MB
            logLevel = .info
            isAnalyticsEnabled = true
            
        case .release:
            apiTimeout = 15.0
            cacheSize = 200 * 1024 * 1024 // 200MB
            logLevel = .warning
            isAnalyticsEnabled = true
        }
    }
}
```

---

## 13. まとめ

### 13.1 技術的な特徴

1. **Clean Architecture**: レイヤー分離による保守性の向上
2. **TDD採用**: テストファーストでの開発による品質保証
3. **非同期処理**: Combine + async/awaitによる現代的な並行処理
4. **セキュリティ**: APIキーの適切な管理と位置情報の保護
5. **パフォーマンス**: マルチレベルキャッシュと並列処理による最適化

### 13.2 開発フェーズ

#### Phase 1: 基盤構築（2週間）
- プロジェクト構成とアーキテクチャ設定
- Domain層のエンティティとユースケース実装
- 基本的なテストスイート構築

#### Phase 2: コア機能実装（3週間）
- API連携（OpenAI, Google Places）
- 位置情報管理とマップ統合
- キャッシュシステム実装

#### Phase 3: UI実装（2週間）
- SwiftUIでの画面実装
- ユーザーフロー完成
- エラーハンドリング強化

#### Phase 4: 統合テスト・最適化（1週間）
- 統合テスト実施
- パフォーマンス最適化
- セキュリティ監査

### 13.3 リスク管理

#### 高リスク項目
1. **API制限**: OpenAI/Google APIの利用制限
2. **位置情報精度**: 到着判定の精度問題
3. **実在性検証**: AI推薦スポットの実在性確認

#### 対策
1. **フォールバック機能**: API失敗時の代替機能
2. **精度調整**: 到着判定範囲の動的調整
3. **二重検証**: Places APIでの実在性確認強化

---

この詳細設計書により、要件定義書の内容を具体的な実装可能な形に落とし込みました。特に「スポット名の秘匿」「到着時の開示」「AI×GoogleMap連携」「TDD開発」といった要件を技術的に実現するための具体的な設計を提供しています。